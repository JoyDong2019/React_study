<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- React并没有将标记与逻辑进行分离到不同的文件中 -->
    <meta charset="UTF-8" />
    <script
      crossorigin
      src="https://unpkg.com/react@16/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      /* 高阶组件是参数为组件，返回值为新组件的函数 组件将props转换为UI 高阶组件将组建转换为另一个组件*/
      /* HOC不会修改传入的组件 也不会使用继承来复制其行为 不要在render方法中使用HOC*/
      // 此函数接收一个组件...
      function withSubscription(WrappedComponent, selectData) {
        // ...并返回另一个组件...
        return class extends React.Component {
          constructor(props) {
            super(props);
            this.handleChange = this.handleChange.bind(this);
            this.state = {
              data: selectData(DataSource, props),
            };
          }

          componentDidMount() {
            // ...负责订阅相关的操作...
            DataSource.addChangeListener(this.handleChange);
          }

          componentWillUnmount() {
            DataSource.removeChangeListener(this.handleChange);
          }

          handleChange() {
            this.setState({
              data: selectData(DataSource, this.props),
            });
          }

          render() {
            // ... 并使用新数据渲染被包装的组件!
            // 请注意，我们可能还会传递其他属性
            return <WrappedComponent data={this.state.data} {...this.props} />;
          }
        };
      }
      const CommentListWithSubscription = withSubscription(
        /* 第一个参数是被包装的组件，第二个参数通过DataSource和当前的props返回我们需要的数据 */
        CommentList,
        (DataSource) => DataSource.getComments()
      );

      const BlogPostWithSubscription = withSubscription(
        BlogPost,
        (DataSource, props) => DataSource.getBlogPost(props.id)
      );
    </script>
    <script type="text/babel">
      /* 不改变原始组件 使用组合 */
      function logProps(WrappedComponent) {
        return class extends React.Component {
          componentDidUpdate(prevProps) {
            console.log("Current props: ", this.props);
            console.log("Previous props: ", prevProps);
          }
          render() {
            // 将 input 组件包装在容器中，而不对其进行修改。Good!
            return <WrappedComponent {...this.props} />;
          }
        };
      }
    </script>
  </body>
</html>
