<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- React并没有将标记与逻辑进行分离到不同的文件中 -->
    <meta charset="UTF-8" />
    <script
      crossorigin
      src="https://unpkg.com/react@16/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <!-- 数据自上而下进行传递 -->
    <script type="text/babel">
      /* Context提供了一种在组件之间共享数据的方法且不必显式通过组件树的逐层传递props */
      /* context的目的是为了共享对于一个组件树而言是“全局”的数据 */
      class App extends React.Component {
        render() {
          return <Toolbar theme="dark" />;
        }
      }

      function Toolbar(props) {
        // Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。
        // 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事，
        // 因为必须将这个值层层传递所有组件。
        return (
          <div>
            <ThemedButton theme={props.theme} />
          </div>
        );
      }

      class ThemedButton extends React.Component {
        render() {
          return <Button theme={this.props.theme} />;
        }
      }
    </script>
    <!-- 使用context 避免通过中间元素传递props-->
    <!-- Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。 -->
    <script type="text/babel">
      // Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。
      // 为当前的 theme 创建一个 context（“light”为默认值）。
      const ThemeContext = React.createContext("light");
      class App extends React.Component {
        render() {
          // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。
          // 无论多深，任何组件都能读取这个值。
          // 在这个例子中，我们将 “dark” 作为当前的值传递下去。
          return (
            <ThemeContext.Provider value="dark">
              <Toolbar />
            </ThemeContext.Provider>
          );
        }
      }

      // 中间的组件再也不必指明往下传递 theme 了。
      function Toolbar() {
        return (
          <div>
            <ThemedButton />
          </div>
        );
      }

      class ThemedButton extends React.Component {
        // 指定 contextType 读取当前的 theme context。
        // React 会往上找到最近的 theme Provider，然后使用它的值。
        // 在这个例子中，当前的 theme 值为 “dark”。
        static contextType = ThemeContext;
        render() {
          return <Button theme={this.context} />;
        }
      }
    </script>
    <script type="text/babel">
      /* 组件组合 */
      /* 这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。 */
      function Page(props) {
        const user = props.user;
        const userLink = (
          /* 只有最顶部的 Page 组件需要知道 Link 和 Avatar 组件是如何使用 user 和 avatarSize 的 */
          <Link href={user.permalink}>
            <Avatar user={user} size={props.avatarSize} />
          </Link>
        );
        return <PageLayout userLink={userLink} />;
      }
      /* // 现在，我们有这样的组件：
      <Page user={user} avatarSize={avatarSize} />
      // ... 渲染出 ...
      <PageLayout userLink={...} />
      // ... 渲染出 ...
      <NavigationBar userLink={...} />
      // ... 渲染出 ...
      {props.userLink} */
    </script>
  </body>
</html>
